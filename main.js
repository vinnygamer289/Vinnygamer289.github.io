window.addEventListener("load", function() { const thirdPartyScript = document.getElementById("thirdPartyScript"); const scriptLoaded = new Promise(resolve => { if (thirdPartyScript) { if (thirdPartyScript.getAttribute("data-loaded") === "true") { resolve(); } else { thirdPartyScript.onload = resolve; } } else { resolve(); } }); scriptLoaded.then(function() { let loader = document.getElementById("loader"); let content = document.getElementById("contents"); if (loader) loader.style.display = "none"; if (content) content.style.display = "block"; document.querySelectorAll("img").forEach(img => { img.onerror = function() { setTimeout(() => { img.src = img.src; }, 1000); }; }); document.querySelectorAll("iframe").forEach(iframe => { iframe.onerror = function() { setTimeout(() => { iframe.src = iframe.src; }, 1000); }; }); }); }); function adjustStyles() { let screenWidth = window.innerWidth; document.body.style.fontSize = `${Math.max(12, Math.min(screenWidth / 50, 24))}px`; document.body.style.paddingBottom = `${Math.max(20, Math.min(screenWidth / 10, 100))}px`; } window.addEventListener("resize", adjustStyles); document.addEventListener("DOMContentLoaded", adjustStyles); document.querySelectorAll("a").forEach(link => { let longPressTimer = null; let longPressTriggered = false; function startPress(e) { longPressTriggered = false; longPressTimer = setTimeout(() => { longPressTriggered = true; e.preventDefault(); }, 500); } function cancelPress() { clearTimeout(longPressTimer); } link.addEventListener("touchstart", startPress); link.addEventListener("touchend", cancelPress); link.addEventListener("touchcancel", cancelPress); link.addEventListener("pointerdown", function(e) { if (e.pointerType === "touch") { startPress(e); } }); link.addEventListener("pointerup", cancelPress); link.addEventListener("pointercancel", cancelPress); link.addEventListener("click", function(e) { if (longPressTriggered) { e.preventDefault(); } }); link.addEventListener("contextmenu", function(e) { e.preventDefault(); }); }); function removeUnusedCSS() { const sheets = document.styleSheets; const usedSelectors = new Set(); let totalRemovedSize = 0; let removedSelectors = []; document.querySelectorAll('*').forEach(element => { if (element.classList.length) { element.classList.forEach(cls => usedSelectors.add('.' + cls)); } if (element.id) { usedSelectors.add('#' + element.id); } usedSelectors.add(element.tagName.toLowerCase()); }); Array.from(sheets).forEach(sheet => { try { const rules = sheet.cssRules || sheet.rules; if (!rules) return; for (let j = rules.length - 1; j >= 0; j--) { const rule = rules[j]; if (!rule.selectorText) continue; const selectors = rule.selectorText.split(',').map(s => s.trim()); let isUsed = selectors.some(sel => { if (usedSelectors.has(sel) || sel === '*') return true; try { const element = document.querySelector(sel); if (element) { const hasJsAttr = Array.from(element.attributes) .some(attr => attr.name.startsWith('js')); return hasJsAttr || true; } return false; } catch (e) { return true; } }); if (!isUsed) { if (/nth-child/.test(rule.selectorText)) continue; if (rule.cssText.indexOf("display: none") > -1) continue; if (/img|body|html|:root|.download-list a|\*|fa-|::before|::after|:hover/.test(rule.selectorText)) continue; totalRemovedSize += rule.cssText.length; removedSelectors.push(rule.selectorText); sheet.deleteRule(j); } } } catch (e) { console.warn('Unable to access stylesheet:', sheet.href); } }); console.log(`Deleted ${(totalRemovedSize / 1024).toFixed(2)} KB of unused CSS.`); console.log("Selectors have been removed:", removedSelectors); } document.addEventListener("DOMContentLoaded", removeUnusedCSS);